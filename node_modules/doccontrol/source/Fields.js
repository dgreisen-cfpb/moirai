// Generated by CoffeeScript 1.4.0

/*
the base Field class and most of the core fields.
*/


(function() {
  var BooleanField, CharField, ChoiceField, EmailField, Field, FloatField, IntegerField, NullBooleanField, RegexField, ValidationError, fields, utils, validators,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (typeof exports !== "undefined" && exports !== null) {
    utils = require("./utils");
    validators = require("./Validators");
  } else if (typeof window !== "undefined" && window !== null) {
    utils = window.utils;
    validators = window.validators;
  }

  ValidationError = utils.ValidationError;

  Field = (function() {
    /*
      Baseclass for all fields. Fields are defined by a schema. You can override attributes and methods within the schema. For example:
    
          var schema = { name: "firstField", field: "Field", required: false };
    
      creates a basic field that is not required. This is not particularly useful. But we can create useful fields using subclasses of Field:
    
          var schema = { name: "badPasswordField" field: "CharField", maxLength: 8, minLength: 4, widget: "Widgets.PasswordWidget" };
    
      Now we have created a very insecure password field. We have overridden the Charfield's default widget with a password widget.
    
      We can create a raw field instance on the frontend or backend by calling `fields.genField(contactSchema)`. Or we can create a frontend
      form by using the schema in a widget.Form constructor as the schema attribute.
    
      Attributes:
    
        * `clean`: the cleaned widget value accessed via `getClean()`; raises error if invalid; this will be a javascript datatype and 
        should be used for any calculations, etc. Use the toJSON() method to get a version appropriate for serialization.
        * `validators`: array of validators; If overriding a parent class, you must include all parent class validators
        * `errorMessages`: hash of error message codes and keys. You can override any error message by setting a new message for the code.
        * `listeners`: hash of listeners of one of the following forms:
          * `'event': (inSender, inEvent) ->`
          * `'event': "handlerMethod"`
          * `'*': "handlerMethod"`
          wildcard will handle all incoming events
        * `widget`: kind definition for widget to display (eg { kind: "widget.Widget"}, or simply the string name of the widget kind)
        * `name`: the name/identifier for this field
        * `required`: whether the current field is required
        * `value`: the current value of the field. access via `getValue()`
        * `initial`: the initial value of the field (for validation)
        * `default`: the default value of the field. if the set value is undefined, the value will be changed to the default value
    
      Default widget: Widget
    */

    Field.prototype.clean = void 0;

    Field.prototype.errors = [];

    Field.prototype.validators = [];

    Field.prototype.errorMessages = {
      required: utils._i('This field is required.')
    };

    /*
      hash of listeners of the form
          * `'event': (inSender, inEvent) ->`
          * `'event': "handlerMethod"`
          * `'*': "handlerMethod"`
      wildcard will handle all incoming events
    */


    Field.prototype.listeners = {};

    Field.prototype.parent = void 0;

    Field.prototype.widget = "widgets.Widget";

    Field.prototype.name = void 0;

    Field.prototype.required = true;

    Field.prototype.value = void 0;

    Field.prototype.initial = void 0;

    Field.prototype["default"] = void 0;

    function Field(opts) {
      var schema, _ref, _ref1, _ref2;
      if (opts == null) {
        opts = {};
      }
      this.opts = utils.clone(opts);
      this.errorMessages = this._walkProto("errorMessages");
      if (opts.errorMessages) {
        utils.mixin(this.errorMessages, opts.errorMessages);
        delete opts.errorMessages;
      }
      this.listeners = {};
      if ((_ref = opts.value) == null) {
        opts.value = opts.initial;
      }
      if ((_ref1 = opts.initial) == null) {
        opts.initial = opts.value;
      }
      utils.mixin(this, opts);
      delete this.value;
      if (((_ref2 = this.parent) != null ? _ref2._fields : void 0) != null) {
        this.parent._fields.push(this);
      }
      this.validators = utils.cloneArray(this.validators);
      this.emit("onFieldAdd", {
        schema: this.opts,
        value: opts.value
      });
      if (this.setSchema) {
        schema = utils.clone(this.schema);
        delete this.schema;
        this.setSchema(schema, {
          value: opts.value
        });
      }
      this.setValue(opts.value);
    }

    Field.prototype._walkProto = function(attr) {
      /* walks the prototype chain collecting all the values off attr and combining them in one.
      */

      var sup;
      sup = this.constructor.__super__;
      if (sup != null) {
        return utils.mixin(utils.clone(sup._walkProto(attr)), this[attr]);
      } else {
        return this[attr];
      }
    };

    Field.prototype.getErrors = function() {
      /* get the errors for this field. returns null if no errors.
      */
      this.isValid();
      if (this.errors.length) {
        return this.errors;
      } else {
        return null;
      }
    };

    Field.prototype.toJavascript = function(value) {
      /*
          First function called in validation process.<br />
          this function converts the raw value to javascript. `value` is the raw value from
          `@getValue()`. The function returns the value in the proper javascript format,<br />
          this function should be able to convert from any type that a widget might supply to the type needed for validation
      */
      return value;
    };

    Field.prototype._valid = false;

    Field.prototype._hasChanged = true;

    Field.prototype.validate = function(value) {
      /*
          Second function called in validation process.<br />
          Any custom validation logic should be placed here. receives the input, `value`, from `toJavascript`'s output.
          return the value with any modifications. When validation fails, throw a utils.ValidationError. with a 
          default error message, a unique error code, and any attributes for string interpolation of the error message
          be sure to call `@super <br />
          default action is to check if the field is required
      */
      if (validators.isEmpty(value) && this.required) {
        throw ValidationError(this.errorMessages.required, "required");
      }
      return value;
    };

    Field.prototype.runValidators = function(value) {
      /*
          Third function called in validation process.<br />
          You should not have to override this function. simply add validators to @validators.
      */

      var v, _i, _len, _ref;
      if (validators.isEmpty(value)) {
        return;
      }
      _ref = this.validators;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        this._catchErrors(v, value);
      }
      return value;
    };

    Field.prototype.isValid = function(opts) {
      /* primary validation function<br />
      calls all other validation subfunctions and emits a `validChanged` event if the valid state has changed.
      returns `true` or `false`
      only precesses the full validation if hasChanged is true, which is only true if something has changed since the last call to isValid()
      emits the `validChanged` event if the valid state has changed.
      */

      var oldErrors, valid, value;
      if (!this._hasChanged) {
        return this._valid;
      }
      oldErrors = utils.clone(this.errors);
      this.errors = [];
      value = this.getValue();
      value = this._catchErrors(this.toJavascript, value);
      if (!this.errors.length) {
        value = this._catchErrors(this.validate, value);
      }
      if (!this.errors.length) {
        value = this.runValidators(value);
      }
      valid = !this.errors.length;
      this.clean = valid ? value : void 0;
      if (valid !== this._valid || !valid && !utils.isEqual(oldErrors, this.errors)) {
        this.emit("onValidChanged", {
          valid: valid,
          errors: this.errors
        });
        this._valid = valid;
      }
      this._hasChanged = false;
      return valid;
    };

    Field.prototype._catchErrors = function(fn, value) {
      /* helper function for running an arbitrary function, capturing errors and placing in error array
      */

      var message;
      try {
        if (fn instanceof Function) {
          value = fn.call(this, value);
        } else {
          value = fn.validate(value);
        }
      } catch (e) {
        message = this.errorMessages[e.code] != null ? this.errorMessages[e.code] : e.message;
        if (e.params != null) {
          message = utils.interpolate(message, e.params);
        }
        this.errors.push(message);
      }
      return value;
    };

    Field.prototype.getClean = function(opts) {
      /*
          return the fild's cleaned data if there are no errors. throws an error if there are validation errors.
          you will likely have to override this in Field subclasses
      */

      var valid;
      valid = this.isValid(opts);
      if (!valid) {
        throw this.errors;
      }
      return this.clean;
    };

    Field.prototype.toJSON = function(opts) {
      /*
          return the field's cleaned data in serializable form if there are no errors. throws an error if there are validation errors.  
          you might have to override this in Field subclasses.
      */
      return this.getClean(opts);
    };

    Field.prototype.setRequired = function(val) {
      if (val !== this.required) {
        this._hasChanged = true;
        this.required = val;
        return this.emit("onRequiredChanged", {
          required: this.required
        });
      }
    };

    Field.prototype.setValue = function(val, opts) {
      /* You should not have to override this in Field subclasses
      */

      var origValue;
      if (val === void 0) {
        val = this["default"];
      }
      if (val !== this.value) {
        this._hasChanged = true;
        origValue = this.value;
        this.value = val;
        return this.emit("onValueChanged", {
          value: this.getValue(),
          original: origValue
        });
      }
    };

    Field.prototype.getValue = function() {
      /* You should not have to override this in Field subclasses
      */
      return this.value;
    };

    Field.prototype.getPath = function() {
      /*
          Get an array of the unique path to the field. A ListField's subfields are denoted by an integer representing the index of the subfield.
          A ContainerField's subfields are denoted by a string or integer representing the key of the subfield.
          Example:
          {parent: {child1: hello, child2: [the, quick, brown, fox]}}
          ["parent", "child2", 1] points to "quick"
          [] points to {parent: {child1: hello, child2: [the, quick, brown, fox]}}
      */
      if (this.parent) {
        return this.parent.getPath(this);
      } else {
        return [];
      }
    };

    Field.prototype.getField = function(path) {
      /* get a field given a path
      */
      if (path.length > 0) {
        return void 0;
      } else {
        return this;
      }
    };

    Field.prototype.emit = function(eventName, inEvent) {
      /*
          emit an event that bubbles up the field tree.
          
          * `eventName`: name of the event to emit
          * `inEvent`: optional hash of data to send with the event
      */
      if (inEvent == null) {
        inEvent = {};
      }
      inEvent.originator = this;
      return this._bubble(eventName, null, inEvent);
    };

    Field.prototype._bubble = function(eventName, inSender, inEvent) {
      /* handle bubbling to parent
      */

      var listener, _i, _len, _ref;
      _ref = this._getProtoListeners(eventName, true);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        listener = _ref[_i];
        if (listener.apply(this, [inSender, inEvent]) === true) {
          return;
        }
      }
      if (this.parent) {
        return this.parent._bubble(eventName, this, inEvent);
      }
    };

    Field.prototype._getProtoListeners = function(eventName, start) {
      /* handle bubbling up the prototype chain
      */

      var listener, sup;
      sup = start ? this.constructor.prototype : this.constructor.__super__;
      listener = this.listeners[eventName] || this.listeners["*"];
      listener = listener instanceof Function ? listener : this[listener];
      listener = listener != null ? [listener] : [];
      if (sup != null) {
        return sup._getProtoListeners(eventName).concat(listener);
      } else {
        return listener;
      }
    };

    return Field;

  })();

  CharField = (function(_super) {

    __extends(CharField, _super);

    /*
      a field that contains a string.  
      Attributes:
    
       * `maxLength`: The maximum length of the string (optional)
       * `minLength`: The minimum length of the string (optional)
    
      Default widget: Widget
    */


    CharField.prototype.maxLength = void 0;

    /* The minimum length of the string (optional)
    */


    CharField.prototype.minLength = void 0;

    function CharField(opts) {
      CharField.__super__.constructor.call(this, opts);
      if (this.maxLength != null) {
        this.validators.push(new validators.MaxLengthValidator(this.maxLength));
      }
      if (this.minLength != null) {
        this.validators.push(new validators.MinLengthValidator(this.minLength));
      }
    }

    CharField.prototype.toJavascript = function(value) {
      value = validators.isEmpty(value) ? "" : value;
      return value;
    };

    return CharField;

  })(Field);

  IntegerField = (function(_super) {

    __extends(IntegerField, _super);

    /*
      a field that contains a whole number.  
      Attributes:  
    
       * `maxValue`: Maximum value of integer
       * `minValue`: Minimum value of integer
    
      Default widget: Widget
    */


    IntegerField.prototype.maxValue = void 0;

    IntegerField.prototype.minValue = void 0;

    IntegerField.prototype.errorMessages = {
      invalid: utils._i('Enter a whole number.')
    };

    function IntegerField(opts) {
      IntegerField.__super__.constructor.call(this, opts);
      if (this.maxValue != null) {
        this.validators.push(new validators.MaxValueValidator(this.maxValue));
      }
      if (this.minValue != null) {
        this.validators.push(new validators.MinValueValidator(this.minValue));
      }
    }

    IntegerField.prototype.parseFn = parseInt;

    IntegerField.prototype.regex = /^-?\d*$/;

    IntegerField.prototype.toJavascript = function(value) {
      if (typeof value === "string" && !value.match(this.regex)) {
        throw ValidationError(this.errorMessages.invalid, "invalid");
      }
      value = validators.isEmpty(value) ? void 0 : this.parseFn(value, 10);
      if ((value != null) && isNaN(value)) {
        throw ValidationError(this.errorMessages.invalid, "invalid");
      }
      return value;
    };

    return IntegerField;

  })(Field);

  FloatField = (function(_super) {

    __extends(FloatField, _super);

    /*
      A field that contains a floating point number.  
      Attributes:
    
        * `maxDecimals`: Maximum number of digits after the decimal point
        * `minDecimals`: Minimum number of digits after the decimal point
        * `maxDigits`: Maximum number of total digits before and after the decimal point
      
      Default widget: Widget
    */


    FloatField.prototype.maxDecimals = void 0;

    FloatField.prototype.minDecimals = void 0;

    FloatField.prototype.maxDigits = void 0;

    FloatField.prototype.errorMessages = {
      invalid: utils._i('Enter a number.')
    };

    function FloatField(opts) {
      FloatField.__super__.constructor.call(this, opts);
      if (this.maxDecimals != null) {
        this.validators.push(new validators.MaxDecimalPlacesValidator(this.maxDecimals));
      }
      if (this.minDecimals != null) {
        this.validators.push(new validators.MinDecimalPlacesValidator(this.minDecimals));
      }
      if (this.maxDigits != null) {
        this.validators.push(new validators.MaxDigitsValidator(this.maxDigits));
      }
    }

    FloatField.prototype.parseFn = parseFloat;

    FloatField.prototype.regex = /^\d*\.?\d*$/;

    return FloatField;

  })(IntegerField);

  RegexField = (function(_super) {

    __extends(RegexField, _super);

    /*
      A baseclass for subclassing.
      Attributes:
    
        * `regex`: the compiled regex to test against
        * `errorMessage`: the error message to display when the regex fails
      
      Default widget: Widget
    */


    RegexField.prototype.regex = void 0;

    RegexField.prototype.errorMessage = void 0;

    function RegexField(opts) {
      RegexField.__super__.constructor.call(this, opts);
      this.validators.push(new validators.RegexValidator(this.regex));
      if (this.errorMessage) {
        this.errorMessages.invalid = this.errorMessage;
      }
    }

    return RegexField;

  })(Field);

  EmailField = (function(_super) {

    __extends(EmailField, _super);

    function EmailField() {
      return EmailField.__super__.constructor.apply(this, arguments);
    }

    /*
      A field that contains a valid email.  
      Attributes:
    
        * None
      
      Default widget: EmailWidget
    */


    EmailField.prototype.widget = "widgets.EmailWidget";

    EmailField.prototype.validators = [new validators.EmailValidator()];

    return EmailField;

  })(RegexField);

  BooleanField = (function(_super) {

    __extends(BooleanField, _super);

    function BooleanField() {
      return BooleanField.__super__.constructor.apply(this, arguments);
    }

    /*
      A field that contains a Boolean value. Must be true or false.
      if you want to be able to store null us `NullBooleanField`
      Attributes:
    
        * none
      
      Default widget: CheckboxWidget
    */


    BooleanField.prototype.widget = "widgets.CheckboxWidget";

    BooleanField.prototype.toJavascript = function(value) {
      if (typeof value === "string" && utils.includes(["false", "0"], value.toLowerCase())) {
        value = false;
      } else {
        value = Boolean(value);
      }
      if (!value && this.required) {
        throw ValidationError(this.errorMessages.required, "required");
      }
      return value;
    };

    return BooleanField;

  })(Field);

  NullBooleanField = (function(_super) {

    __extends(NullBooleanField, _super);

    function NullBooleanField() {
      return NullBooleanField.__super__.constructor.apply(this, arguments);
    }

    /*
      A field that contains a Boolean value. The value can be 
      true, false, or null.  
      Attributes:
    
        * none
      
      Default widget: CheckboxWidget
    */


    NullBooleanField.prototype.toJavascript = function(value) {
      if (utils.includes([true, "True", "1"], value)) {
        value = true;
      } else if (utils.includes([false, "False", "0"], value)) {
        value = false;
      } else {
        value = null;
      }
      return value;
    };

    NullBooleanField.prototype.validate = function(value) {
      return value;
    };

    return NullBooleanField;

  })(BooleanField);

  ChoiceField = (function(_super) {

    __extends(ChoiceField, _super);

    /*
      A field that contains value from a list of values.  
      Attributes:
    
        * `choices`: Array of 2-arrays specifying valid choices. if 2-arrays, first value is value, second is display. create optgroups by setting display If display value to a 2-array. MUST USE `setChoices`.
      
      Default widget: ChoiceWidget
    */


    ChoiceField.prototype.widget = "widgets.ChoiceWidget";

    ChoiceField.prototype.choices = [];

    ChoiceField.prototype.errorMessages = {
      invalidChoice: utils._i('Select a valid choice. %(value)s is not one of the available choices.')
    };

    function ChoiceField(opts) {
      if (opts.choices) {
        this.choices = opts.choices;
      }
      this.setChoices(utils.cloneArray(this.choices));
      ChoiceField.__super__.constructor.call(this, opts);
    }

    ChoiceField.prototype.setChoices = function(val) {
      var choices, iterChoices;
      choices = {};
      iterChoices = function(x) {
        if (x[1] instanceof Array) {
          return utils.forEach(x[1], iterChoices);
        } else {
          return choices[x[0]] = x[1];
        }
      };
      utils.forEach(this.choices, iterChoices);
      return this.choicesIndex = choices;
    };

    ChoiceField.prototype.toJavascript = function(value) {
      value = validators.isEmpty(value) ? "" : value;
      return value;
    };

    ChoiceField.prototype.validate = function(value) {
      value = ChoiceField.__super__.validate.call(this, value);
      if (value && !this.validValue(value)) {
        throw ValidationError(this.errorMessages.invalidChoice, "invalidChoice", value);
      }
      return value;
    };

    ChoiceField.prototype.validValue = function(val) {
      return val in this.choicesIndex;
    };

    ChoiceField.prototype.getDisplay = function() {
      return this.choices[this.getClean()];
    };

    return ChoiceField;

  })(Field);

  fields = {
    Field: Field,
    CharField: CharField,
    IntegerField: IntegerField,
    FloatField: FloatField,
    RegexField: RegexField,
    EmailField: EmailField,
    BooleanField: BooleanField,
    NullBooleanField: NullBooleanField,
    ChoiceField: ChoiceField,
    getField: function(path) {
      var out, part, _i, _len;
      path = path.split(".");
      out = this;
      for (_i = 0, _len = path.length; _i < _len; _i++) {
        part = path[_i];
        out = out[part];
      }
      return out;
    },
    genField: function(schema, parent, value) {
      var field;
      schema = utils.clone(schema);
      schema.parent = parent;
      if (value != null) {
        schema.value = value;
      }
      field = this.getField(schema.field);
      if (!field) {
        throw Error("Unknown field: " + schema.field);
      }
      return new field(schema);
    }
  };

  if (typeof window !== "undefined" && window !== null) {
    window.fields = fields;
  } else if (typeof exports !== "undefined" && exports !== null) {
    require("./ContainerFields")(fields);
    module.exports = fields;
  }

}).call(this);
